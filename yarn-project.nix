# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

{ lib, nodejs, python3, yarn-berry, stdenv, fetchurl, writeText, writeShellScriptBin, git, cacert, gnused, writeTextFile }:
{ src,
  symlinkPackages ? false,
  overrideAttrs ? null,
  netrcFilePath ? null,
  secretsEnvVars ? null,
  yarnPath ? null,
  yarnPluginsPaths ? null,
  ...
} @ args:
let
  yarnExe = if builtins.isNull yarnPath
    then "${yarn-berry}/bin/yarn"
    else "node '${yarnPath}'";
  yarnLock = ./yarn.lock;
  packageJson = ./package.json;
  yarnrcYaml = builtins.path {
    path = ./.yarnrc.yml;
    name = "yarnrc.yml";
  };
  yarnPlugins = if (builtins.pathExists ./.yarn/plugins)
  then
    builtins.path {
      path = ./.yarn/plugins;
      name = "yarnPlugins";
    }
  else
    null;

  cacheFolder = ".yarn/cache";

  # Call overrideAttrs on a derivation if a function is provided.
  optionalOverride = fn: drv:
    if fn == null then drv else drv.overrideAttrs fn;

  # Common attributes between Yarn derivations.
  drvCommon = {
    # Make sure the build uses the right Node.js version everywhere.
    buildInputs = [ nodejs python3 yarn-berry ];
    # Tell node-gyp to use the provided Node.js headers for native code builds.
    npm_config_nodedir = nodejs;
    # Tell node-pre-gyp to never fetch binaries / always build from source.
    npm_config_build_from_source = "true";
    # Defines the shell alias to run Yarn.
    postHook = ''
      yarn() {
        CI=1 ${yarnExe} "$@"
      }
    '';
  };

  setupProjectFiles = ''
    # package.json cannot be symlinked since when executing "yarn run ...", yarn
    # will follow the symlink and consider the location of the original file as
    # the projects root directory.
    cp ${packageJson} package.json

    ln -s ${yarnLock} yarn.lock
    ln -s ${yarnrcYaml} .yarnrc.yml

    mkdir -p .yarn

    ${lib.optionalString (yarnPlugins!= null) ''
      ln -s ${yarnPlugins} .yarn/plugins
    ''}

    ${lib.optionalString (yarnPluginsPaths != null) ''
      export YARN_PLUGINS=${yarnPluginsPaths}
    ''}
  '';

  checkSandboxPathExists = writeShellScriptBin "check-sandbox-file-exists" ''
    set -ueo pipefail

    file_path=$1

    if ! [[ -e "$file_path" && -r "$file_path" ]]
    then
      echo >&2 "Error: $file_path does not exist or cannot be accessed due to permissions!"
      echo >&2 "  Make sure it's added to extra-sandbox-paths and that nixbld"
      echo >&2 "  user group has read access to it."
      exit 1
    fi
  '';

  linkNetrcFile = writeShellScriptBin "link-netrc-file" ''
    set -ueo pipefail

    netrc_file_path=$1
    home=$2

    ${lib.getExe checkSandboxPathExists} "$netrc_file_path"

    if ! test -d "$home";
    then
      echo >&2 "given HOME path (''${home}) does not exist or is not a directory"
      exit 1
    fi

    echo >&2 "linking .netrc file at ''${netrc_file_path} to ''${home}"

    ln -s "$netrc_file_path" "$home"
  '';

  exportEnvVarsFromFilesIfAny = envVarNamesToPaths:
    if envVarNamesToPaths != null
    # build a list of export statement
    then lib.concatStringsSep "\n" (lib.mapAttrsToList
      (name: path: ''
        ${lib.getExe checkSandboxPathExists} "${path}"
        export ${name}=$(cat "${path}")
      '')
      envVarNamesToPaths
    )
    else ""
  ;

  # Create derivations for fetching dependencies.
  cacheDrvs = let
    builder = writeTextFile {
      name = "builder.sh";
      text = ''
      source $stdenv/setup

      ${exportEnvVarsFromFilesIfAny secretsEnvVars}

      home=$TMP

      ${
        if netrcFilePath != null
        then ''link-netrc-file "${netrcFilePath}" "$home"''
        else ""
      }

      build_dir=$TMP/build
      mkdir -p $build_dir
      cd $build_dir

      ${setupProjectFiles}

      mkdir -p ${cacheFolder}
      YARN_CACHE_FOLDER=$(pwd)/${cacheFolder}

      # TODO see how to avoid using yarnExe here
      HOME="$home" \
        YARN_CACHE_FOLDER="$YARN_CACHE_FOLDER" \
        CI=1 \
        ${yarnExe} nixify fetch-one $locator

      # Because we change the cache dir, Yarn may generate a different name.
      output_filename_stripped=$(sed 's/-[^-]*\.[^-]*$//' <<< "$outputFilename")

      mv "$YARN_CACHE_FOLDER/$output_filename_stripped"-* $out
    '';
    };
  in lib.mapAttrs (locator: { filename, sha512 }: stdenv.mkDerivation {
    inherit builder locator;
    # We need .zip extension since without pnp will not look inside the archive.
    name = lib.strings.sanitizeDerivationName locator + ".zip";
    buildInputs = [ nodejs ];
    nativeBuildInputs = [ git cacert linkNetrcFile python3 yarn-berry ];
    outputFilename = filename;
    outputHashMode = "flat";
    outputHashAlgo = "sha512";
    outputHash = sha512;
  }) cacheEntries;

  # Create a shell snippet to copy dependencies from a list of derivations.
  mkCacheBuilderForDrvs = symlinkPackages: drvs:
    writeText "collect-cache.sh" (lib.concatMapStrings (drv: ''
      ${if symlinkPackages then "ln -s" else "cp"} ${drv} '${drv.outputFilename}'
    '') drvs);

  # Create a shell snippet to copy dependencies from a list of locators.
  mkCacheBuilderForLocators = let
    pickCacheDrvs = map (locator: cacheDrvs.${locator});
  in locators:
    mkCacheBuilderForDrvs false (pickCacheDrvs locators);

  # Create a derivation that builds a node-pre-gyp module in isolation.
  mkIsolatedBuild = { pname, version, reference, locators }: stdenv.mkDerivation (drvCommon // {
    inherit pname version;
    phases = [ "buildPhase" "installPhase" ];

    buildPhase = ''
      runHook preBuild

      mkdir -p .yarn/cache
      pushd .yarn/cache > /dev/null
      source ${mkCacheBuilderForLocators locators}
      popd > /dev/null

      echo '{ "dependencies": { "${pname}": "${reference}" } }' > package.json
      install -m 0600 ${yarnLock} ./yarn.lock

      yarn_global_folder="$TMP" \
        YARN_ENABLE_IMMUTABLE_INSTALLS=false \
        yarn --immutable-cache

      runHook postBuild
    '';

    installPhase = ''
      unplugged=( .yarn/unplugged/${pname}-*/node_modules/* )
      if [[ ! -e "''${unplugged[@]}" ]]; then
        echo >&2 "Could not find the unplugged path for ${pname}"
        exit 1
      fi

      mv "$unplugged" $out
    '';
  });

  # Derivation with content of .yarn/cache and .pnp.cjs
  deps = stdenv.mkDerivation (drvCommon // {
    name = "yarn-3-test-deps";
    # Disable Nixify plugin to save on some unnecessary processing.
    yarn_enable_nixify = "false";

    configurePhase = ''
      output_dir=$out/libexec/deps
      mkdir -p $output_dir
      cd $output_dir

      ${setupProjectFiles}

      # Copy over the Yarn cache.
      mkdir -p ${cacheFolder}
      pushd '${cacheFolder}' > /dev/null
      source ${mkCacheBuilderForDrvs symlinkPackages (lib.attrValues cacheDrvs)}
      popd > /dev/null

      # Copy in isolated builds.
      echo 'injecting build for node-module-test'
      yarn nixify inject-build \
        "node-module-test@https://github.com/adrian-gierakowski/node-module-test.git#commit=3bbac84988bcccc7cd83d5124594c43983b022ac" \
        ${isolated."node-module-test@https://github.com/adrian-gierakowski/node-module-test.git#commit=3bbac84988bcccc7cd83d5124594c43983b022ac"} \
        ".yarn/unplugged/node-module-test-https-03a5c12099/node_modules/node-module-test"
      echo 'running yarn install'

      runHook postConfigure
    '';

    dontUnpack = true;
    dontBuild = true;

    installPhase = ''
      runHook preInstall

      # Yarn may need a writable home directory.
      export yarn_global_folder="$TMP"

      # Some node-gyp calls may call out to npm, which could fail due to an
      # read-only home dir.
      export HOME="$TMP"

      # running preConfigure after the cache is populated allows for
      # preConfigure to contain substituteInPlace for dependencies as well as the
      # main project. This is necessary for native bindings that maybe have
      # hardcoded values.
      runHook preConfigure

      # Run normal Yarn install to complete dependency installation.
      # YARN_VIRTUAL_FOLDER is set this way to make it easy to replace in
      # installPhase below, so that in the end virtual paths resolve to
      # packages in nix store.
      YARN_CACHE_FOLDER=$(pwd)/${cacheFolder} \
        CI=1 ${yarnExe} install --immutable --immutable-cache

      runHook postInstall
    '';

    passthru = {
      inherit nodejs;
    };
  });

  # Main project derivation.
  project = stdenv.mkDerivation (drvCommon // {
    inherit src;
    name = "yarn-3-test";

    nativeBuildInputs = [gnused python3];

    depsPath = "${deps}/libexec/deps";

    configurePhase = ''
      ${setupProjectFiles}
      # We can't symlink this one since it doesn't work as a symlink due to
      # packageLocations within it being relative path to this files locations
      # real location, therefore it needs to be located at the root of the
      # project for relative and workspace scoped imports to work.
      cp $depsPath/.pnp.* .

      runHook postConfigure
    '';

    dontBuild = true;

    installPhase = ''
      runHook preInstall

      app_dir=$out/libexec/$name
      bin_dir=$out/bin

      mkdir -p $(dirname $app_dir) $out/bin

      # Move the entire project to the output directory.
      mv $PWD $app_dir
      cd $app_dir

      # sed helpers
      escape_sed_replacement () {
        echo "$1" | sed -e 's/[\/&]/\\&/g'
      }

      escape_sed_pattern () {
        echo "$1" | sed -e 's/[]\/$*.^[]/\\&/g'
      }

      # Replace packageLocation for the workspace and main package.
      sed_pattern='"packageLocation": "'$depsPath'/"'
      sed_replace='"packageLocation": "'$app_dir'/"'

      sed -E -i \
        -e "s/$(escape_sed_pattern "$sed_pattern")/$(escape_sed_replacement "$sed_replace")/g" \
        .pnp.cjs

      # Invoke a plugin internal command to setup binaries.
      ${yarnExe} nixify install-bin $bin_dir

      runHook postInstall
    '';

    passthru = {
      inherit nodejs;
    };
  });

cacheEntries = {
"lodash@npm:4.17.21" = { filename = "lodash-npm-4.17.21-6382451519-eb835a2e51.zip"; sha512 = "eb835a2e51d381e561e508ce932ea50a8e5a68f4ebdd771ea240d3048244a8d13658acbd502cd4829768c56f2e16bdd4340b9ea141297d472517b83868e677f7"; };
"node-module-test@https://github.com/adrian-gierakowski/node-module-test.git#commit=3bbac84988bcccc7cd83d5124594c43983b022ac" = { filename = "node-module-test-https-03a5c12099-19b083b8d6.zip"; sha512 = "19b083b8d65f6094ac4bec5d9ccd4c063d31b20d67a52d86f50889881a9087eaef2d28a7b0a16ae379c1d9b75f288e1019d69c9602a312b2522fd2ed86471547"; };
"ramda@npm:0.29.0" = { filename = "ramda-npm-0.29.0-ec4babb485-9ab26c06eb.zip"; sha512 = "9ab26c06eb7545cbb7eebcf75526d6ee2fcaae19e338f165b2bf32772121e7b28192d6664d1ba222ff76188ba26ab307342d66e805dbb02c860560adc4d5dd57"; };
};
isolated."node-module-test@https://github.com/adrian-gierakowski/node-module-test.git#commit=3bbac84988bcccc7cd83d5124594c43983b022ac" = optionalOverride (args.overrideNodeModuleTestAttrs or null) (mkIsolatedBuild { pname = "node-module-test"; version = "1.0.0"; reference = "https://github.com/adrian-gierakowski/node-module-test.git#commit=3bbac84988bcccc7cd83d5124594c43983b022ac"; locators = [
"lodash@npm:4.17.21"
"node-module-test@https://github.com/adrian-gierakowski/node-module-test.git#commit=3bbac84988bcccc7cd83d5124594c43983b022ac"
"ramda@npm:0.29.0"
]; });
in optionalOverride overrideAttrs project
