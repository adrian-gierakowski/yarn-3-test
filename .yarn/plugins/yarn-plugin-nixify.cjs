module.exports={name:"yarn-plugin-nixify",factory:function(e){var t;return(()=>{"use strict";var n={d:(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},a={};n.r(a),n.d(a,{default:()=>w});const o=e("@yarnpkg/core"),r=e("clipanion");class i extends r.Command{constructor(...e){super(...e),this.locator=r.Option.String()}async execute(){const e=await o.Configuration.find(this.context.cwd,this.context.plugins),{project:t}=await o.Project.find(e,this.context.cwd),n=await o.Cache.find(e),a=e.makeFetcher();return(await o.StreamReport.start({configuration:e,stdout:this.context.stdout},(async e=>{const{locatorHash:r}=o.structUtils.parseLocator(this.locator,!0),i=t.originalPackages.get(r);i?await a.fetch(i,{checksums:t.storedChecksums,project:t,cache:n,fetcher:a,report:e}):e.reportError(0,"Invalid locator")}))).exitCode()}}i.paths=[["nixify","fetch-one"]];const s=e("@yarnpkg/fslib"),c=e("crypto");class l extends r.Command{constructor(...e){super(...e),this.locator=r.Option.String(),this.source=r.Option.String(),this.installLocation=r.Option.String()}async execute(){const e=await o.Configuration.find(this.context.cwd,this.context.plugins),{project:t}=await o.Project.find(e,this.context.cwd);return(await o.StreamReport.start({configuration:e,stdout:this.context.stdout},(async n=>{await t.resolveEverything({report:n,lockfileOnly:!0});const a=o.structUtils.parseLocator(this.locator,!0),r=t.storedPackages.get(a.locatorHash);if(!r)return void n.reportError(0,"Invalid locator");const i=s.ppath.join(t.cwd,this.installLocation);await s.xfs.mkdirpPromise(s.ppath.dirname(i)),await o.execUtils.execvp("cp",["-R",this.source,i],{cwd:t.cwd,strict:!0}),await o.execUtils.execvp("chmod",["-R","u+w",i],{cwd:t.cwd,strict:!0});const l=(0,c.createHash)("sha512");l.update(process.versions.node),e.triggerHook((e=>e.globalHashGeneration),t,(e=>{l.update("\0"),l.update(e)}));const d=l.digest("hex"),p=new Map,h=e=>{let n=p.get(e.locatorHash);if(void 0!==n)return n;const a=t.storedPackages.get(e.locatorHash);if(void 0===a)throw new Error("Assertion failed: The package should have been registered");const r=(0,c.createHash)("sha512");r.update(e.locatorHash),p.set(e.locatorHash,"<recursive>");for(const e of a.dependencies.values()){const n=t.storedResolutions.get(e.descriptorHash);if(void 0===n)throw new Error(`Assertion failed: The resolution (${o.structUtils.prettyDescriptor(t.configuration,e)}) should have been registered`);const a=t.storedPackages.get(n);if(void 0===a)throw new Error("Assertion failed: The package should have been registered");r.update(h(a))}return n=r.digest("hex"),p.set(e.locatorHash,n),n},u=(0,c.createHash)("sha512").update(d).update(h(r)).update(i).digest("hex");t.storedBuildState.set(r.locatorHash,u),await t.persistInstallStateFile()}))).exitCode()}}l.paths=[["nixify","inject-build"]];const d=e("@yarnpkg/plugin-pnp"),p=JSON.stringify,h=(e,t,n=!1)=>t.split("\n").map((t=>t||n?e+t:t)).join("\n"),u=(e,t)=>{let n=e;for(const[e,a]of Object.entries(t))if("string"==typeof a&&(n=n.replace(new RegExp(`@@${e}@@`,"g"),a)),"boolean"==typeof a){const t=n.split("\n"),o=t.indexOf(`#@@ IF ${e}`),r=t.indexOf(`#@@ ENDIF ${e}`);-1!==o&&r>o&&(a?(t.splice(r,1),t.splice(o,1)):t.splice(o,r-o+1),n=t.join("\n"))}return n},f=["pnp","node-modules"];class g extends r.Command{constructor(...e){super(...e),this.binDir=r.Option.String()}async execute(){const e=await o.Configuration.find(this.context.cwd,this.context.plugins),{project:t,workspace:n}=await o.Project.find(e,this.context.cwd);return(await o.StreamReport.start({configuration:e,stdout:this.context.stdout},(async a=>{if(!n||0===n.manifest.bin.size)return;let o=e.get("nodeLinker");f.includes(o)||(o="node-modules",a.reportWarning(0,`The nodeLinker ${o} is not supported - executables may have trouble finding dependencies`));const r=s.npath.toPortablePath(this.binDir),i=(0,d.getPnpPath)(t).cjs;for(const[e,a]of n.manifest.bin){const n=s.ppath.join(r,e),c=s.ppath.join(t.cwd,s.npath.toPortablePath(a));let l;switch(o){case"pnp":l=u("#!/bin/sh\nexport NODE_OPTIONS=\"--require @@PNP_PATH@@\"\nexec '@@NODE_PATH@@' '@@SCRIPT_PATH@@' \"$@\"\n",{NODE_PATH:process.execPath,PNP_PATH:i,SCRIPT_PATH:c});break;case"node-modules":l=u("#!/bin/sh\nexec '@@NODE_PATH@@' '@@SCRIPT_PATH@@' \"$@\"\n",{NODE_PATH:process.execPath,SCRIPT_PATH:c});break;default:throw Error(`Assertion failed: Invalid nodeLinker ${o}`)}await s.xfs.writeFilePromise(n,l),await s.xfs.chmodPromise(n,493)}}))).exitCode()}}g.paths=[["nixify","install-bin"]];const m=e("@yarnpkg/plugin-patch"),y=(e,t)=>(0,c.createHash)(e).update(t).digest(),x=(e,t,n,a="/nix/store")=>{const o=n.toString("hex"),r=y("sha256",`fixed:out:${t}:${o}:`).toString("hex"),i=(e=>{let t="",n=[...e].reverse().map((e=>e.toString(2).padStart(8,"0"))).join("");for(;n;)t+="0123456789abcdfghijklmnpqrsvwxyz"[parseInt(n.slice(0,5),2)],n=n.slice(5);return t})(((e,t)=>{const n=Buffer.alloc(20);for(let t=0;t<e.length;t++)n[t%20]^=e[t];return n})(y("sha256",`output:out:sha256:${r}:${a}:${e}`)));return s.ppath.join(a,`${i}-${e}`)},v=e=>e.replace(/^\.+/,"").replace(/[^a-zA-Z0-9+._?=-]+/g,"-").slice(0,207)||"unknown",b=e("os"),P={commands:[i,l,g],hooks:{afterAllInstalled:async(e,t)=>{!1!==t.persistProject&&e.configuration.get("enableNixify")&&await(async(e,t,n)=>{const{configuration:a,cwd:r}=e,i=await s.xfs.realpathPromise(s.npath.toPortablePath((0,b.tmpdir)()));if(e.cwd.startsWith(i))return void n.reportInfo(0,`Skipping Nixify, because ${e.cwd} appears to be a temporary directory`);const c=a.get("yarnPath");let l=s.ppath.relative(r,c);l.startsWith("../")&&(l=c,n.reportWarning(0,`The Yarn path ${c} is outside the project - it may not be reachable by the Nix build`));const d=a.get("cacheFolder");let f=s.ppath.relative(r,d);f.startsWith("../")&&(f=d,n.reportWarning(0,`The cache folder ${d} is outside the project - it may not be reachable by the Nix build`));for(const e of a.sources.values())e.startsWith("<")||s.ppath.relative(r,e).startsWith("../")&&n.reportWarning(0,`The config file ${e} is outside the project - it may not be reachable by the Nix build`);const g=a.get("nixExprPath"),y=a.get("lockfileFilename"),P=s.ppath.relative(s.ppath.dirname(g),y),w=s.ppath.relative(s.ppath.dirname(g),l),$=new Map,k=new Set(await s.xfs.readdirPromise(t.cwd)),T={unstablePackages:e.conditionalLocators};for(const n of e.storedPackages.values()){const{locatorHash:a}=n,r=e.storedChecksums.get(a),i=t.getLocatorPath(n,r||null,T);if(!i)continue;const c=s.ppath.basename(i);if(!k.has(c))continue;const l=o.structUtils.stringifyLocator(n),d=r?r.split("/").pop():await o.hashUtils.checksumFile(i);$.set(l,{filename:c,sha512:d})}let E="cacheEntries = {\n";for(const[e,t]of $)E+=`${p(e)} = { ${[`filename = ${p(t.filename)};`,`sha512 = ${p(t.sha512)};`].join(" ")} };\n`;E+="};";const S=a.get("isolatedNixBuilds");let A=new Set,j=[],N=[];const _=a.get("nodeLinker"),C=a.get("pnpUnpluggedFolder"),I=(t,n=new Set)=>{const a=o.structUtils.stringifyLocator(t);if($.has(a)&&n.add(a),o.structUtils.isVirtualLocator(t)){const a=e.storedPackages.get(o.structUtils.devirtualizeLocator(t).locatorHash);if(!a)throw Error("Assertion failed: The locator should have been registered");I(a,n)}if(t.reference.startsWith("patch:")){const a=e.storedPackages.get(m.patchUtils.parseLocator(t).sourceLocator.locatorHash);if(!a)throw Error("Assertion failed: The locator should have been registered");I(a,n)}for(const a of t.dependencies.values()){const t=e.storedResolutions.get(a.descriptorHash);if(!t)throw Error("Assertion failed: The descriptor should have been registered");const o=e.storedPackages.get(t);if(!o)throw Error("Assertion failed: The locator should have been registered");I(o,n)}return n};for(const t of e.storedBuildState.keys()){const n=e.storedPackages.get(t);if(!n)throw Error("Assertion failed: The locator should have been registered");if(!S.includes(n.name))continue;let a;if("pnp"!==_)throw Error(`The nodeLinker ${_} is not supported for isolated Nix builds`);a=s.ppath.relative(e.cwd,s.ppath.join(C,o.structUtils.slugifyLocator(n),o.structUtils.getIdentVendorPath(n)));let r=n;if(o.structUtils.isVirtualLocator(r)){const{locatorHash:t}=o.structUtils.devirtualizeLocator(r),n=e.storedPackages.get(t);if(!n)throw Error("Assertion failed: The locator should have been registered");r=n}const i=o.structUtils.stringifyLocator(r),c=o.structUtils.stringifyLocator(n),l=`isolated.${p(i)}`;if(!A.has(r)){A.add(r);const e=[...I(n)].sort().map((e=>`${p(e)}\n`)).join(""),t=`override${L=n.name,L.split(/[^a-zA-Z0-9]+/g).filter((e=>e)).map((e=>{return(t=e).slice(0,1).toUpperCase()+t.slice(1);var t})).join("")}Attrs`;N.push(`${l} = optionalOverride (args.${t} or null) (mkIsolatedBuild { ${[`pname = ${p(n.name)};`,`version = ${p(n.version)};`,`locators = [\n${e}];`].join(" ")} });`)}0===j.length&&j.push("# Copy in isolated builds."),j.push(`echo 'injecting build for ${n.name}'`,"yarn nixify inject-build \\",`  ${p(c)} \\`,`  \${${l}} \\`,`  ${p(a)}`)}var L;j.length>0&&j.push("echo 'running yarn install'");const O=e.topLevelWorkspace.manifest.name,H=O?o.structUtils.stringifyIdent(O):"workspace",D=u('# This file is generated by running "yarn install" inside your project.\n# Manual changes might be lost - proceed with caution!\n\n{ lib, nodejs, stdenv, fetchurl, writeText }:\n{ src, symlinkPackages ? false, overrideAttrs ? null, netrcFilePath ? null, envVarNamesToPathStrings ? null, ... } @ args:\n\nlet\n\n  yarnPath = ./@@YARN_PATH@@;\n  yarnPathString = "./@@YARN_PATH@@";\n  yarnLock = ./@@LOCKFILE@@;\n  packageJson = ./package.json;\n  yarnrcYaml = builtins.path {\n    path = ./.yarnrc.yml;\n    name = "yarnrc.yml";\n  };\n  yarnPlugins = builtins.path {\n    path = ./.yarn/plugins;\n    name = "yarnPlugins";\n  };\n\n  cacheFolder = @@CACHE_FOLDER@@;\n\n  # Call overrideAttrs on a derivation if a function is provided.\n  optionalOverride = fn: drv:\n    if fn == null then drv else drv.overrideAttrs fn;\n\n  # Common attributes between Yarn derivations.\n  drvCommon = {\n    # Make sure the build uses the right Node.js version everywhere.\n    buildInputs = [ nodejs ];\n    # Tell node-gyp to use the provided Node.js headers for native code builds.\n    npm_config_nodedir = nodejs;\n    # Tell node-pre-gyp to never fetch binaries / always build from source.\n    npm_config_build_from_source = "true";\n    # Defines the shell alias to run Yarn.\n    postHook = \'\'\n      yarn() {\n        CI=1 node "${yarnPath}" "$@"\n      }\n    \'\';\n  };\n\n  # Create derivations for fetching dependencies.\n  cacheDrvs = let\n    builder = builtins.toFile "builder.sh" \'\'\n      source $stdenv/setup\n      ${\n        if envVarNamesToPathStrings != null\n        # build a list of export statement\n        then lib.concatStringsSep "\\n" (lib.mapAttrsToList\n          (name: path: "export ${name}=$(cat ${path})")\n          envVarNamesToPathStrings\n        )\n        else ""\n      }\n\n      yarn_cache_dir=$TMP\n\n      cd $TMP\n      ln -s ${yarnLock} yarn.lock\n      ln -s ${packageJson} package.json\n      ln -s ${yarnrcYaml} .yarnrc.yml\n      ln -s ${yarnPlugins} .yarn/plugins\n\n      mkdir -p $(dirname yarnPathString)\n      echo yarnPath: ${yarnPath}\n      echo yarnPathString: ${yarnPathString}\n      ln -s ${yarnPath} ${yarnPathString}\n\n      echo ls .yarn\n      ls .yarn\n\n      HOME="$TMP" \\\n        yarn_cache_folder="$yarn_cache_dir" \\\n        CI=1 \\\n        node ${yarnPath} nixify fetch-one $locator\n\n      # Because we change the cache dir, Yarn may generate a different name.\n      mv "$yarn_cache_dir/$(sed \'s/-[^-]*\\.[^-]*$//\' <<< "$outputFilename")"-* $out\n    \'\';\n  in lib.mapAttrs (locator: { filename, sha512 }: stdenv.mkDerivation {\n    inherit src builder locator;\n    name = lib.strings.sanitizeDerivationName locator;\n    buildInputs = [ nodejs ];\n    outputFilename = filename;\n    outputHashMode = "flat";\n    outputHashAlgo = "sha512";\n    outputHash = sha512;\n  }) cacheEntries;\n\n  # Create a shell snippet to copy dependencies from a list of derivations.\n  mkCacheBuilderForDrvs = drvs:\n    writeText "collect-cache.sh" (lib.concatMapStrings (drv: \'\'\n      ${if symlinkPackages then "ln -s" else "cp"} ${drv} \'${drv.outputFilename}\'\n    \'\') drvs);\n\n#@@ IF NEED_ISOLATED_BUILD_SUPPRORT\n  # Create a shell snippet to copy dependencies from a list of locators.\n  mkCacheBuilderForLocators = let\n    pickCacheDrvs = map (locator: cacheDrvs.${locator});\n  in locators:\n    mkCacheBuilderForDrvs (pickCacheDrvs locators);\n\n  # Create a derivation that builds a node-pre-gyp module in isolation.\n  mkIsolatedBuild = { pname, version, locators }: stdenv.mkDerivation (drvCommon // {\n    inherit pname version;\n    phases = [ "buildPhase" "installPhase" ];\n\n    buildPhase = \'\'\n      mkdir -p .yarn/cache\n      pushd .yarn/cache > /dev/null\n      source ${mkCacheBuilderForLocators locators}\n      popd > /dev/null\n\n      echo \'{ "dependencies": { "${pname}": "${version}" } }\' > package.json\n      install -m 0600 ${yarnLock} ./yarn.lock\n      export yarn_global_folder="$TMP"\n      export YARN_ENABLE_IMMUTABLE_INSTALLS=false\n      yarn --immutable-cache\n    \'\';\n\n    installPhase = \'\'\n      unplugged=( .yarn/unplugged/${pname}-*/node_modules/* )\n      if [[ ! -e "\'\'${unplugged[@]}" ]]; then\n        echo >&2 "Could not find the unplugged path for ${pname}"\n        exit 1\n      fi\n\n      mv "$unplugged" $out\n    \'\';\n  });\n#@@ ENDIF NEED_ISOLATED_BUILD_SUPPRORT\n\n  # Main project derivation.\n  project = stdenv.mkDerivation (drvCommon // {\n    inherit src;\n    name = @@PROJECT_NAME@@;\n    # Disable Nixify plugin to save on some unnecessary processing.\n    yarn_enable_nixify = "false";\n\n    configurePhase = \'\'\n      # Copy over the Yarn cache.\n      rm -fr \'${cacheFolder}\'\n      mkdir -p \'${cacheFolder}\'\n      pushd \'${cacheFolder}\' > /dev/null\n      source ${mkCacheBuilderForDrvs (lib.attrValues cacheDrvs)}\n      popd > /dev/null\n\n      # Yarn may need a writable home directory.\n      export yarn_global_folder="$TMP"\n\n      # Some node-gyp calls may call out to npm, which could fail due to an\n      # read-only home dir.\n      export HOME="$TMP"\n\n      # running preConfigure after the cache is populated allows for\n      # preConfigure to contain substituteInPlace for dependencies as well as the\n      # main project. This is necessary for native bindings that maybe have\n      # hardcoded values.\n      runHook preConfigure\n\n@@ISOLATED_INTEGRATION@@\n\n      # Run normal Yarn install to complete dependency installation.\n      yarn install --immutable --immutable-cache\n\n      runHook postConfigure\n    \'\';\n\n    buildPhase = \'\'\n      runHook preBuild\n      runHook postBuild\n    \'\';\n\n    installPhase = \'\'\n      runHook preInstall\n\n      mkdir -p $out/libexec $out/bin\n\n      # Move the entire project to the output directory.\n      mv $PWD "$out/libexec/$sourceRoot"\n      cd "$out/libexec/$sourceRoot"\n\n      # Invoke a plugin internal command to setup binaries.\n      yarn nixify install-bin $out/bin\n\n      runHook postInstall\n    \'\';\n\n    passthru = {\n      inherit nodejs;\n    };\n  });\n\n@@CACHE_ENTRIES@@\n@@ISOLATED@@\nin optionalOverride overrideAttrs project\n',{PROJECT_NAME:p(H),YARN_PATH:w,LOCKFILE:P,CACHE_FOLDER:p(f),CACHE_ENTRIES:E,ISOLATED:N.join("\n"),ISOLATED_INTEGRATION:h("      ",j.join("\n")),NEED_ISOLATED_BUILD_SUPPRORT:j.length>0});if(await s.xfs.writeFilePromise(a.get("nixExprPath"),D),a.get("generateDefaultNix")){const e=s.ppath.join(r,"default.nix"),t=s.ppath.join(r,"flake.nix");s.xfs.existsSync(e)||s.xfs.existsSync(t)||(await s.xfs.writeFilePromise(e,"# This is a minimal `default.nix` by yarn-plugin-nixify. You can customize it\n# as needed, it will not be overwritten by the plugin.\n\n{ pkgs ? import <nixpkgs> { } }:\n\npkgs.callPackage ./yarn-project.nix { } { src = ./.; }\n"),n.reportInfo(0,"A minimal default.nix was created. You may want to customize it."))}a.get("enableNixPreload")&&s.xfs.existsSync(s.npath.toPortablePath("/nix/store"))&&await s.xfs.mktempPromise((async a=>{const r=[];for(const[e,{filename:n,sha512:o}]of $.entries()){const i=v(e),c=Buffer.from(o,"hex"),l=x(i,"sha512",c);if(!s.xfs.existsSync(l)){const e=s.ppath.join(a,o.slice(0,7));await s.xfs.mkdirPromise(e);const c=s.ppath.join(t.cwd,n),l=s.ppath.join(e,i);await s.xfs.copyFilePromise(c,l),r.push(l)}}try{const t=r.length;for(;0!==r.length;){const t=r.splice(0,100);await o.execUtils.execvp("nix-store",["--add-fixed","sha512",...t],{cwd:e.cwd,strict:!0})}0!==t&&n.reportInfo(0,`Preloaded ${t} packages into the Nix store`)}catch(e){if("ENOENT"!==e.code)throw e}}))})(e,t.cache,t.report)}},configuration:{enableNixify:{description:"If false, disables the Nixify plugin hook that generates Nix expressions",type:o.SettingsType.BOOLEAN,default:!0},nixExprPath:{description:"Path of the file where the project Nix expression will be written to",type:o.SettingsType.ABSOLUTE_PATH,default:"./yarn-project.nix"},generateDefaultNix:{description:"If true, a default.nix will be generated if it does not exist",type:o.SettingsType.BOOLEAN,default:!0},enableNixPreload:{description:"If true, cached packages will be preloaded into the Nix store",type:o.SettingsType.BOOLEAN,default:!0},isolatedNixBuilds:{description:"Dependencies with a build step that can be built in an isolated derivation",type:o.SettingsType.STRING,default:[],isArray:!0}}},w=P;t=a})(),t}};